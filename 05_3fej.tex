\chapter{Opportunities and internals of SUDS}

\section{Introduction}

As I described in section \ref{suds}, SUDS is the de facto way of consuming web services in Python. One of the most compelling features lies within its simplicity and user friendliness. These help in the beginning, by making it really easy to create a working prototype in no time, both by using the interactive shell and writing scripts -- but later, the code is still readable, and at the same time, caching helps eliminating the performance trade-off. A sample run, consuming a currency rate service using SUDS in the interactive Python shell can be seen in Figure \ref{fig:suds-currency}.

\begin{figure}[htbp]
 \centering
\begin{lstlisting}[numbers=off, basicstyle=\footnotesize\ttfamily]
Python 2.7.2+ (default, Aug 16 2011, 07:03:08)
[GCC 4.6.1] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from suds.client import Client
>>> url = 'http://www.webservicex.net/CurrencyConvertor.asmx?WSDL'
>>> c = Client(url)
>>> print c

Suds ( https://fedorahosted.org/suds/ )  version: 0.4.1 (beta)  build: R703-20101015

Service ( CurrencyConvertor ) tns="http://www.webserviceX.NET/"
   Prefixes (1)
      ns0 = "http://www.webserviceX.NET/"
   Ports (2):
      (CurrencyConvertorSoap)
         Methods (1):
            ConversionRate(Currency FromCurrency, Currency ToCurrency, )
         Types (1):
            Currency
      (CurrencyConvertorSoap12)
         Methods (1):
            ConversionRate(Currency FromCurrency, Currency ToCurrency, )
         Types (1):
            Currency


>>> c.service.ConversionRate('EUR', 'HUF')
315.6003
\end{lstlisting}
 \caption{Requesting currency conversion rate using SUDS}
 \label{fig:suds-currency}
\end{figure}

\section{Internal structure}

In order to improve SUDS, I had to discover its inner workings -- the documentation covered standard use-cases pretty well, but told little about architecture. I split the code in time domain into two pieces, the separator being the end of \emph{suds.client.Client} object instatiation. Before that, WSDL fetching and parsing happens, and afterwards, during invocations, SOAP messages are built, sent, and responses are parsed and returned.

\subsection{Client proxy instantiation}

% TODO

\subsection{Service method invocation}

% TODO

\subsection{Document Object Model of SUDS}

As \cite{w3schools-domintro} defines it, ``XML DOM is a standard for how to get, change, add, or delete XML elements'', which is the better way to construct XML output -- the worse being string concatenation. SUDS has its own implementation, and as \cite{suds-doc} states, it ``was written [because] elementtree and other [Python] XML packages either: have a DOM API which is very unfriendly or: (in the case of elementtree) do not deal with namespaces and especially prefixes sufficiently'' -- and in retrospect, it was a perfectly sane decision back then. The SUDS DOM resides in the \emph{suds.sax} module, and interfaces the outside world with the Python built-in SAX parser. It registers itself as a SAX event handler, and builds the document tree from its own objects in response to parsing events, so there is a clear separation between the Python XML library and the implementation of SUDS.

Although now we have LXML (see section \ref{lxml}) which would have satisfied those conditions (and is used by rpclib), it was probably not in this state of maturity, when the SUDS project kicked off. It has its own peculiarities, such as namespace handling is done using (prefix, namespace) tuples -- in constrast with standard notations such as dictionary objects or James Clark style. This self-developed solution also caused the appearance of ``double namespaces'' -- the SOAP-ENV namespace was declared with one prefix for the envelope and header, and another for the body. While working on improving SUDS, I also found that it had several deficiencies, for instance, there's no way of handling attributes with namespaces. It could seem, that now it'd be time to replace the library with a thin wrapper around LXML or some other functionally equivalent components, but it'd break existing code depending on the internals of SUDS.

\section{Opportunities}

\subsection{Current WS-Security implementation}

\subsubsection{Timestamp}

% TODO

\subsubsection{UsernameToken}
\label{sudsUsernameToken}

% TODO

\subsection{Plugin system}

% TODO
